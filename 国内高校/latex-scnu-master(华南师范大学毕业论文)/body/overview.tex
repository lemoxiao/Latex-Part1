\subsection{传输层协议 1.3 版本简介}

TLS 协议由两层协议组成：TLS 记录协议和 TLS 握手协议。TLS 1.3 协议只支持 (EC)DHE 的密钥协商算法，删除的 RSA 密钥协商算法和静态 DH 密钥协商算法，更好地提供向前保密性，防止心脏出血攻击，移除所有有安全隐患的密码和密码模式，并且唯一允许的对称加密是 AEAD。除了 ClientHello 和 ServerHello 报文外，其他握手报文全部加密，这在 1.2版本并没有。服务器现在签署了整个握手，计算 HMAC 的时候使用全部握手信息，防止降级攻击。

并且不再允许对加密报文进行压缩、禁止重协商。TLS 1.3 握手协议用于协商连接的安全参数，包括密钥协商，参数协商，建立共享密钥，负责协商使用的 TLS 版本、加密算法、哈希算法、密钥材料和其他与通信过程有关的信息，对服务器进行身份认证，对客户端进行可选的身份认证，最后对整个握手阶段信息进行完整性校验以防范中间人攻击，是整个 TLS 协议的核心。

握手有三个阶段: 第一阶段：密钥交换。 第二阶段：服务器端参数。 第三阶段：认证。 TLS 1.3 协议握手有两种模式：一种是 1-RTT 握手，另一种是 0-RTT 握手。在 1-RTT 模式下客户端和服务器端只需要进过一次往返就能完成协商连接需要用到的安全参数，并且完成身份验证。在 0-RTT 模式中，客户端通过发送 PSK 和 early\_data完成握手和身份验证，其中 PSK 用于恢复主密钥，early\_data 的是经过加密的应用层数据，比如发送的一次 GET 请求。客户端和服务器端在没有数据往返情况下从 PSK 中导出 early\_data 解密密钥，解密 early\_data 数据。0-RTT 模式的握手需要3个条件：

1.客户端和服务器端不是第一次握手连接，并且之前的连接服务器端发送了 Session Ticket，Session Ticket 中包含愿意接受 early\_data 的 max\_early\_data\_size。

2. 不是第一次握手时，客户端发送了 PSK 和 early\_data。

3. 服务器端读取客户端发送过来的 early\_data。

TLS 1.3 记录协议负责接收要传输的应用层数据，将数据分段为合适的长度，输入密钥、随机字符串，使用 AEAD 算法加密分段后的数据，添加记录层头部并传输最后处理结果。收到的数据经过验证，解密，重新组装，然后交付给更上层的协议。信息块分段为 TLSPlaintext 记录，TLSPlaintext 中包含 2\^14 字节或更少字节块的数据。记录保护功能将 TLSPlaintext 结构转换为 TLSCiphertext 结构。去除保护功能和保护功能互为逆过程。其中使用 Pre-Record Nonce 分别维护 64 位序列号以读取和写入记录，Pre-Record Nonce 是按网络字节顺序编码的64位序列号和 client\_write\_iv 或 server\_write\_iv 异或得到。在读取或写入每个记录之后，适当的序列号加 1。每个序列号在连接开始时和每次更改密钥时都设置为零，在特定流量密钥下传输的第一条记录必须使用序列号 0。因为序列号的大小是64位，所以它们不应该换行。

如果 TLS 实现方需要 wrap 序列号，它必须重新生成密钥或终止连接。每个 AEAD 算法将为 Per-record 的随机数指定一系列可能的长度，从 N\_MIN 字节到输入的 N\_MAX 字节[RFC5116]。 对于 AEAD 算法，TLS 的 Per-record 随机数(iv\_length)的长度设置为 8 字节和 N\_MIN 中的较大者(参见[RFC5116]，第4节)。 其中 N\_MAX 小于 8 个字节的 AEAD 算法不得与 TLS 一起使用。所有加密的 TLS 记录都可以被填充，从而扩大 TLSCiphertext 的大小。这种做法允许发送者对攻击者隐藏流量大小。生成 TLSCiphertext 记录时，实现方可以选择填充。未填充的记录只是填充长度为零的记录。填充是在加密之前附加到 ContentType 字段的一串零值字节。实现方必须在加密之前将填充的八位字节全部设置为零。

TLS 警报协议发送的 Alert 消息传达警报的描述以及在先前版本的 TLS 中传达消息严重性级别的遗留字段。警报分为两类：关闭警报和错误警报。TLS 提供 Alert 内容类型用来表示关闭信息和错误。与其他消息一样，Alert 消息也会根据当前连接状态的进行加密。收到错误警报后，TLS 实现方应该向应用程序表示出现了错误，并且不允许在连接上发送或接收任何其他数据。服务器端和客户端必须删除的旧连接中建立的秘密值和密钥。客户端和服务器端必须共享连接结束的状态，以避免截断攻击。任何一方都可以通过发送 close\_notify 警报来发起其连接写入端的关闭。收到关闭警报后收到的任何数据都必须被忽略。当检测到错误时，检测的这一方，向其对等方发送消息。在传输或收到致命警报消息时，双方必须立即关闭连接，而不发送或接收任何其他数据。
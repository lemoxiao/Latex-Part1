\section{总结与展望}

\subsection{总结}

  首次接触前端后端开发，在工具 webpack、vue.js、Node.js、expressjs 中遇到很多问题，上网搜索解决问题，看官网文档，慢慢从零基础到入门，勉强能完成基本功能。刚开始遇到浏览器跨域问题，虽然知道了它的原理，但是在解决方法上到处碰壁，在问答社区和请教同学才得以解决。实现过程中体会到 JavaScript 和 C/C++ 语言的很多差异，其中最突出的是 JavaScript 因为运行在 V8引擎上，不能直接操作内存，在实现密钥生成、加密算法、密钥导出等操作的时候，需要用到 JavaScript 中 Buffer 操作，通过操作 Buffer 代替操作 内存二进制数，很长一段时间没能适应，在编程中带来不少困难。

  TLS 1.3 协议带来的启发：对称加密算法、MAC 算法、数字签名算法、密钥交换算法，四类基础算法的选择。对称加密算法选择更现代化、可证明安全的 AEAD 算法，其中最优的选择是 AES-256-GCM、ChaCha20-poly1305。数字签名和密钥交换可以选择速度更快，以及安全性相同但是密钥长度更短的椭圆曲线加密法。全面使用 SHA-2 算法，SHA-1 已经被破解了。全面使用 (EC)DH 密钥交换，考虑到前向保密性和使用 RSA 对服务器的性能要求，以及 RSA 私钥的保管有更大的风险。

  少而精的 TLS 1.3，启用它可以更进一步改善用户体验，同时安全性也更有保障。对于 TLS 1.3 的 0-RTT 重放攻击，可以实现在 Ticker 有效期内的抗重放攻击，并且就测试结果来看，在重放攻击时服务器的占用资源也可以接受，在未确保 0-RTT 安全性时，服务器可以选择完全拒绝 0-RTT。措施一：检查 Ticker 有效期和唯一性一起使用，可以抵抗 0-RTT，但是会增加数据库的读写操作，减低服务器性能。措施二：检查 Ticker 有效期和添加 Early Data 请求头组合，根据实际业务需要灵活处理检查和处理 0-RTT。建议禁用 0-RTT 握手模式直到安全审计确定重放攻击不会对服务器造成威胁。测试 1-RTT 和 0-RTT 握手对比：1-RTT 模式下 TCP 握手开始到 TLS 完成握手发送第一个请求数据耗时 0.025504 毫秒，0-RTT 模式下 TCP 握手开始到TLS 发送早期数据耗时 0.002199毫秒，速度提升了 91.37\%。

\subsection{展望}

  本文实验测试比较简单，尽管实验中能解决 0-RTT 的重放攻击，可能存在效率更高效的方法没有发现，另外本文中 0-RTT 的前向保密性问题还没有涉及。有望能在以后的 TLS 版本更新中解决前向保密性问题。2015年，Young Kyung Lee 和 Dong Hoon Lee\cite{7292984}等人提出从不可区分混淆中进行前向安全的非交互式密钥交换。2017年4月,Günther, Felix and Hale\cite{inproceedings1}等人提出利用一种可穿透的密钥封装方案，该方案允许每个密文只被解密一次解决前向保密性。2017年 6月，Hale, Britta and Jager\cite{inproceedings0}等人提出可证明安全的简单安全模型。相信关于 TLS 1.3 的 0-RTT 问题能得到更好解决，为每个用户和每个设备提供更快，更安全的网络。

\newpage